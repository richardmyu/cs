# 复杂查询

## 视图

### 视图和表

视图究竟是什么呢？如果用一句话概述的话，就是“从 SQL 的角度来看视图就是一张表”。实际上，在 SQL 语句中并不需要区分哪些是表，哪些是视图，只需要知道在更新时它们之间存在一些不同就可以了。

那么视图和表到底有什么不同呢？区别只有一个，那就是“是否保存了实际的数据”。

通常，我们在创建表时，会通过 `INSERT` 语句将数据保存到数据库之中，而数据库中的数据实际上会被保存到计算机的存储设备（通常是硬盘）中。因此，我们通过 `SELECT` 语句查询数据时，实际上就是从存储设备（硬盘）中读取数据，进行各种计算之后，再将结果返回给用户这样一个过程。

但是使用视图时并不会将数据保存到存储设备之中，而且也不会将数据保存到其他任何地方。实际上视图保存的是 `SELECT` 语句。我们从视图中读取数据时，视图会在内部执行该 `SELECT` 语句并创建出一张临时表。

> 表中存储的是实际数据，而视图中保存的是从表中取出数据所使用的 `SELECT` 语句。

- **视图的优点**

视图的优点大体有两点。

第一点是由于视图无需保存数据，因此可以节省存储设备的容量。

第二个优点就是可以将频繁使用的 `SELECT` 语句保存成视图，这样就不用每次都重新书写了。特别是在进行汇总以及复杂的查询条件导致 `SELECT` 语句非常庞大时，使用视图可以大大提高效率。而且，视图中的数据会随着原表的变化自动更新。

> 视图归根到底就是 `SELECT` 语句，所谓“参照视图”也就是“执行 `SELECT` 语句”的意思，因此可以保证数据的最新状态。这也是将数据保存在表中所不具备的优势（数据保存在表中时，必须要显式地执行 SQL 更新语句才能对数据进行更新。）。

### 创建视图的方法

创建视图需要使用 `CREATE VIEW` 语句：

```sql
CREATE VIEW 视图名称(<视图列名1>, <视图列名2>, ……)
AS
<SELECT语句>

-- example
CREATE VIEW ProductSum (product_type, cnt_product)
AS
SELECT product_type, COUNT(*)
  FROM Product
 GROUP BY product_type;
```

*视图就是保存好的 `SELECT` 语句*。定义视图时可以使用任何 `SELECT` 语句，既可以使用 `WHERE`、`GROUP BY`、`HAVING`，也可以通过 `SELECT *` 来指定全部列。

> 对多数 DBMS 来说，**多重视图** 会降低 SQL 的性能。所以，应该避免在视图的基础上创建视图。

### 定义视图时不能使用 ORDER BY 子句

定义视图时可以使用任何 `SELECT` 语句，但其实有一种情况例外，那就是不能使用 `ORDER BY` 子句。这是因为视图和表一样，数据行都是没有顺序的。实际上，有些 DBMS 在定义视图的语句中是可以使用 `ORDER BY` 子句的（例如，在 PostgreSQL 中上述 SQL 语句就没有问题，可以执行），但是这并不是通用的语法。因此，在定义视图时请不要使用 `ORDER BY` 子句。

### 对视图进行更新

标准 SQL 中有这样的规定：如果定义视图的 `SELECT` 语句能够满足某些条件，那么这个视图就可以被更新。比较具有代表性的条件：

1. `SELECT` 子句中未使用 `DISTINCT`
2. `FROM` 子句中只有一张表
3. 未使用 `GROUP BY` 子句
4. 未使用 `HAVING` 子句

视图归根结底还是从表派生出来的，因此，如果原表可以更新，那么视图中的数据也可以更新。反之亦然，如果视图发生了改变，而原表没有进行相应更新的话，就无法保证数据的一致性了。视图和表需要同时进行更新，因此通过汇总得到的视图无法进行更新（不是通过汇总得到的视图就可以进行更新）。

```sql
-- 创建视图（不可更新视图）
CREATE VIEW ProductSum (product_type, cnt_product)
AS
SELECT product_type, COUNT(*)
  FROM Product
 GROUP BY product_type;
INSERT INTO ProductSum VALUES ('电器制品', 5);
/*
错误:  无法插入到视图"productsum"
描述:  包含 GROUP BY 的视图列不能自动更新.
提示:  启用向视图插入操作, 要提供 INSTEAD OF INSERT
       触发器或者提供一个无条件的 ON INSERT DO INSTEAD 规则.
*/

-- 创建视图（可更新视图）
CREATE VIEW ProductJim (product_id,
  product_name,
  product_type,
  sale_price,
  purchase_price,
  regist_date)
AS
SELECT *
  FROM Product
 WHERE product_type = '办公用品';
INSERT INTO ProductJim VALUES ('0009','银子','办公用品', 95, 10, '2009-11-30');
-- INSERT 0 1

/*
 product_id | product_name | product_type | sale_price | purchase_price | regist_date
------------+--------------+--------------+------------+----------------+-------------
 0001       | T恤          | 衣服         |       1000 |            500 | 2009-09-20
 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11
 0003       | 运动T恤      | 衣服         |       4000 |           2800 |
 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-09-20
 0005       | 高压锅       | 厨房用具     |       6800 |           5000 | 2009-01-15
 0006       | 叉子         | 厨房用具     |        500 |                | 2009-09-20
 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2008-04-28
 0008       | 圆珠笔       | 办公用品     |        100 |                | 2009-11-11
 0009       | 印章         | 办公用品     |         95 |             10 | 2009-11-30

 product_id | product_name | product_type | sale_price | purchase_price | regist_date
------------+--------------+--------------+------------+----------------+-------------
 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11
 0008       | 圆珠笔       | 办公用品     |        100 |                | 2009-11-11
 0009       | 印章         | 办公用品     |         95 |             10 | 2009-11-30
*/
```

> `UPDATE` 语句和 `DELETE` 语句当然也可以像操作表时那样正常执行，但是对于原表来说却需要设置各种各样的约束（主键和 `NOT NULL` 等），需要特别注意。

### 删除视图

```sql
DROP VIEW 视图名称(<视图列名1>, <视图列名2>, ……)

-- 删除以视图为基础创建出来的多重视图
DROP VIEW ProductSum;
/*
错误:  无法删除 视图 productsum 因为有其它对象倚赖它
描述:  视图 productsumjim 倚赖于 视图 productsum
提示:  使用 DROP .. CASCADE 把倚赖对象一并删除.
*/

DROP VIEW ProductSum CASCADE;
/*
注意:  递归删除 视图 productsumjim
DROP VIEW
*/
```

## 子查询

### 子查询和视图

视图并不是用来保存数据的，而是通过保存读取数据的 `SELECT` 语句的方法来为用户提供便利。反之，子查询就是将用来定义视图的 `SELECT` 语句直接用于 `FROM` 子句当中。

> 子查询的特点概括起来就是一张一次性视图。

```sql
SELECT product_type, cnt_product
  -- 首先会执行 FROM 子句中的 SELECT 语句，然后才会执行外层的 SELECT 语句
  FROM (SELECT product_type, COUNT(*) AS cnt_product
           FROM Product
         GROUP BY product_type)
  AS ProductSum;
/*
 product_type | cnt_product
--------------+-------------
 衣服         |           2
 办公用品     |           2
 厨房用具     |           4
*/
```

由于子查询的层数原则上没有限制，因此可以像“子查询的 `FROM` 子句中还可以继续使用子查询，该子查询的 `FROM` 子句中还可以再使用子查询……”这样无限嵌套下去。但是，随着子查询嵌套层数的增加，SQL 语句会变得越来越难读懂，性能也会越来越差。

### 子查询的名称

原则上子查询必须设定名称，因此尽量从处理内容的角度出发为子查询设定恰当的名称。为子查询设定名称时需要使用 `AS` 关键字，该关键字有时也可以省略 （其中也有像 Oracle 这样，在名称之前使用 `AS` 关键字就会发生错误的数据库）。

### 标量子查询

**标量** 就是单一的意思，在数据库之外的领域也经常使用。**标量子查询** (scalar subquery)就是返回单一值的子查询。

> 由于返回的是单一的值，因此标量子查询的返回值可以用在 `=` 或者 `<>` 这样需要单一值的比较运算符之中。这也正是标量子查询的优势所在。

```sql
SELECT product_id, product_name, sale_price
  FROM Product
 WHERE sale_price > (SELECT AVG(sale_price) FROM Product);
```

### 标量子查询的熟书写位置

标量子查询的书写位置并不仅仅局限于 `WHERE` 子句中，通常任何可以使用单一值的位置都可以使用。也就是说，能够使用常数或者列名的地方，无论是 `SELECT` 子句、`GROUP BY` 子句、`HAVING` 子句，还是 `ORDER BY` 子句，几乎所有的地方都可以使用。

### 使用标量子查询的注意事项

子查询绝对不能返回多行结果。也就是说，如果子查询返回了多行结果，那么它就不再是标量子查询，而仅仅是一个普通的子查询了，因此不能被用在 `=` 或者 `<>` 等需要单一输入值的运算符当中，也不能用在 `SELECT` 等子句当中。

## 关联子查询

### 普通的子查询和关联子查询的区别

在对表中某一部分记录的集合进行比较时，就可以使用关联子查询。

```sql
SELECT product_type, product_name, sale_price
  FROM Product
 WHERE sale_price > (SELECT AVG(sale_price)
                       FROM Product
                      GROUP BY product_type);
/*
错误:  作为一个表达式使用的子查询返回了多列
*/

SELECT product_type, product_name, sale_price
  FROM Product AS P1
 WHERE sale_price > (SELECT AVG(sale_price)
                       FROM Product AS P2
                       -- 在同一商品种类中对各商品的销售单价和平均单价进行比较
                       WHERE P1.product_type = P2.product_type);
```

### 关联子查询也是用来对集合进行切分的

换个角度来看，其实关联子查询也和 `GROUP BY` 子句一样，可以对集合进行切分。

### 结合条件一定要卸载子查询中

使用关联子查询时经常犯的一个错误，那就是将关联条件写在子查询之外的外层查询之中。

```sql
SELECT product_type, product_name, sale_price
  FROM Product AS P1
 WHERE P1.product_type = P2.product_type
   AND sale_price > (SELECT AVG(sale_price)
                       FROM Product AS P2
                       GROUP BY product_type);
/*
错误:  对于表"p2",丢失FROM子句项
第3行 WHERE P1.product_type = P2.product_type
*/
```

允许存在这样的书写方法可能并不奇怪，但是 SQL 的规则禁止这样的书写方法。该书写方法究竟违反了什么规则呢？那就是 **关联名称的作用域**。关联名称就是像 P1、P2 这样作为表别名的名称，作用域（scope）就是生存范围（有效范围）。也就是说，关联名称存在一个有效范围的限制。

# 集合运算

[TOC]

## 1.表的加减法

### 1.1.什么是集合运算

**集合** 在数学领域表示“（各种各样的）事物的总和”，在数据库领域表示 **记录的集合**。具体来说，表、视图和查询的执行结果都是记录的集合。

所谓 **集合运算**，就是对满足同一规则的记录进行的加减等四则运算。通过集合运算，可以得到两张表中记录的集合或者公共记录的集合，又或者其中某张表中的记录的集合。像这样用来进行集合运算的运算符称为 **集合运算符**。

### 1.2.表的加法 —— `UNION`（并集）

进行记录加法运算的 **UNION**（并集）。

```sql
/*
Product
+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-09-20  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | NULL        |
| 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-09-20  |
| 0005       | 高压锅       | 厨房用具     |       6800 |           5000 | 2009-01-15  |
| 0006       | 叉子         | 厨房用具     |        500 |           NULL | 2009-09-20  |
| 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2008-04-28  |
| 0008       | 圆珠笔       | 办公用品     |        100 |           NULL | 2009-11-11  |
+------------+--------------+--------------+------------+----------------+-------------+

Product2
+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2008-09-20  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | NULL        |
| 0009       | 手套         | 衣服         |        800 |            500 | NULL        |
| 0010       | 水壶         | 厨房用具     |       2000 |           1700 | 2009-09-20  |
+------------+--------------+--------------+------------+----------------+-------------+
*/
SELECT
  product_id,
  product_name
FROM
  Product
UNION
SELECT
  product_id,
  product_name
FROM
  Product2;
/*
+------------+--------------+
| product_id | product_name |
+------------+--------------+
| 0001       | T恤衫        |
| 0002       | 打孔器       |
| 0003       | 运动T恤      |
| 0004       | 菜刀         |
| 0005       | 高压锅       |
| 0006       | 叉子         |
| 0007       | 擦菜板       |
| 0008       | 圆珠笔       |
| 0009       | 手套         |
| 0010       | 水壶         |
+------------+--------------+
*/
```

`UNION` 等集合运算符通常都会除去重复的记录。

### 1.3.集合运算的注意事项

所有运算符都要遵守这些注意事项。

1. 作为运算对象的【记录的列数】必须相同；

2. 作为运算对象的【记录中列的类型】必须一致；

3. 可以使用任何 `SELECT` 语句，但 `ORDER BY` 子句只能在最后使用一次；

```sql
-- 列数不一致时会发生错误
SELECT
  product_id,
  product_name
FROM
  Product
UNION
SELECT
  product_id,
  product_name,
  sale_price
FROM
  Product2;
/*
 错误：每一个 UNION 查询必须有相同的字段个数
 第 4 行 SELECT product_id, product_name, sale_price
 */

-- 数据类型不一致时会发生错误
SELECT
  product_id,
  sale_price
FROM
  Product
UNION
SELECT
  product_id,
  regist_date
FROM
  Product2;
/*
错误：UNION 的类型 integer 和 date 不匹配
第 4 行 SELECT product_id, regist_date
*/

SELECT
  product_id,
  product_name
FROM
  Product
WHERE
  product_type = "厨房用具"
UNION
SELECT
  product_id,
  product_name
FROM
  Product2
WHERE
  product_type = "厨房用具"
ORDER BY
  product_id;
/*
+------------+--------------+
| product_id | product_name |
+------------+--------------+
| 0004       | 菜刀         |
| 0005       | 高压锅       |
| 0006       | 叉子         |
| 0007       | 擦菜板       |
| 0010       | 水壶         |
+------------+--------------+
*/
```

### 1.4.包含重复行的集合运算 —— `ALL` 选项

在 `UNION` 的结果中保留重复行的语法。其实非常简单，只需要在 `UNION` 后面添加 `ALL` 关键字就可以了。这里的 `ALL` 选项，在 `UNION` 之外的集合运算符中同样可以使用。

```sql
SELECT
  product_id,
  product_name
FROM
  Product
UNION ALL
SELECT
  product_id,
  product_name
FROM
  Product2;
/*
+------------+--------------+
| product_id | product_name |
+------------+--------------+
| 0001       | T恤衫        |
| 0002       | 打孔器       |
| 0003       | 运动T恤      |
| 0004       | 菜刀         |
| 0005       | 高压锅       |
| 0006       | 叉子         |
| 0007       | 擦菜板       |
| 0008       | 圆珠笔       |
| 0001       | T恤衫        |
| 0002       | 打孔器       |
| 0003       | 运动T恤      |
| 0009       | 手套         |
| 0010       | 水壶         |
+------------+--------------+
*/
```

### 1.5.选取表中公共部分 —— `INTERSECT`（交集）

选取两个记录集合中公共部分的 **INTERSECT**（交集）。

> MySQL 不支持 `INTERSECT` 操作符。

```sql
-- pg
SELECT
  product_id,
  product_name
FROM
  Product
INTERSECT
SELECT
  product_id,
  product_name
FROM
  Product2
ORDER BY
  product_id;
/*
 product_id | product_name
------------+--------------
 0001       | T恤衫
 0002       | 打孔器
 0003       | 运动T恤
*/

-- mysql
-- 使用 INNER JOIN 子句来模拟 INTERSECT
SELECT
  P1.product_id,
  P1.product_name
FROM
  Product AS P1
  INNER JOIN Product2 AS P2 ON P1.product_id = p2.product_id;

-- 使用 IN 子句和 子查询 来模拟 INTERSECT
SELECT
  product_id,
  product_name
FROM
  Product AS P1
WHERE
  product_id IN (
    SELECT
      product_id
    FROM
      Product2
  );

-- 使用 EXISTS 子句来模拟 INTERSECT
SELECT
  product_id,
  product_name
FROM
  Product AS P1
WHERE
  EXISTS (
    SELECT
      product_id
    FROM
      Product2 AS P2
    WHERE
      P1.product_id = P2.product_id
  );
```

与使用 `AND` 可以选取出一张表中满足多个条件的公共部分不同，`INTERSECT` 应用于两张表，选取出它们当中的公共记录。

### 1.6.记录的减法 —— `EXCEPT`

> 只有 Oracle 不使用 `EXCEPT`，而是使用其特有的 `MINUS` 运算符。此外，MySQL 还不支持 `EXCEPT`，因此也无法使用。

进行减法运算的 **EXCEPT**（差集）。`EXCEPT` 有一点与 `UNION` 和 `INTERSECT` 不同，需要注意一下，那就是在减法运算中减数和被减数的位置不同，所得到的结果也不相同。

```sql
-- pg
SELECT
  product_id,
  product_name
FROM
  Product
EXCEPT
SELECT
  product_id,
  product_name
FROM
  Product2
ORDER BY
  product_id;
/*
 product_id | product_name
------------+--------------
 0004       | 菜刀
 0005       | 高压锅
 0006       | 叉子
 0007       | 擦菜板
 0008       | 圆珠笔
*/

SELECT
  product_id,
  product_name
FROM
  Product2
EXCEPT
SELECT
  product_id,
  product_name
FROM
  Product
ORDER BY
  product_id;
/*
 product_id | product_name
------------+--------------
 0009       | 手套
 0010       | 水壶
*/

-- mysql
-- 使用 NOT IN 子句和 子查询 来模拟 EXCEPT
SELECT
  product_id,
  product_name
FROM
  Product AS P1
WHERE
  product_id NOT IN (
    SELECT
      product_id
    FROM
      Product2
  );

-- 使用 NOT EXISTS 子句来模拟 EXCEPT
SELECT
  product_id,
  product_name
FROM
  Product AS P1
WHERE
  NOT EXISTS (
    SELECT
      product_id
    FROM
      Product2 AS P2
    WHERE
      P1.product_id = P2.product_id
  );
```

## 2.联结（以列为单位对表进行联结）

### 2.1.什么是联结

集合运算的特征就是以行方向为单位进行操作。通俗地说，就是进行这些集合运算时，会导致记录行数的增减，但是这些运算不会导致列数的改变。

**联结**（JOIN）运算，简单来说，*就是将其他表中的列添加过来，进行“添加列”的运算*。该操作通常用于无法从一张表中获取期望数据（列）的情况。

### 2.2.内联结 —— `INNER JOIN`

**内联结**（INNER JOIN），是应用最广泛的联结运算。

```sql
SELECT
  SP.shop_id,
  SP.shop_name,
  P.product_id,
  P.product_name,
  P.sale_price
FROM
  ShopProduct AS SP
  INNER JOIN Product AS P ON SP.product_id = P.product_id;
/*
+---------+-----------+------------+--------------+------------+
| shop_id | shop_name | product_id | product_name | sale_price |
+---------+-----------+------------+--------------+------------+
| 000A    | 东京      | 0001       | T恤衫        |       1000 |
| 000A    | 东京      | 0002       | 打孔器       |        500 |
| 000A    | 东京      | 0003       | 运动T恤      |       4000 |
| 000B    | 名古屋    | 0002       | 打孔器       |        500 |
| 000B    | 名古屋    | 0003       | 运动T恤      |       4000 |
| 000B    | 名古屋    | 0004       | 菜刀         |       3000 |
| 000B    | 名古屋    | 0006       | 叉子         |        500 |
| 000B    | 名古屋    | 0007       | 擦菜板       |        880 |
| 000C    | 大阪      | 0003       | 运动T恤      |       4000 |
| 000C    | 大阪      | 0004       | 菜刀         |       3000 |
| 000C    | 大阪      | 0006       | 叉子         |        500 |
| 000C    | 大阪      | 0007       | 擦菜板       |        880 |
| 000D    | 福冈      | 0001       | T恤衫        |       1000 |
+---------+-----------+------------+--------------+------------+
*/
```

关于内联结，注意以下三点：

1. **`FROM` 子句**

```sql
FROM
  ShopProduct AS SP
  INNER JOIN Product AS P
```

使用关键字 `INNER JOIN` 就可以将两张表联结在一起了。SP 和 P 分别是这两张表的别名，但别名并不是必需的。

2. **`ON` 子句**

```sql
ON SP.product_id = P.product_id
```

在 `ON` 之后指定两张表联结所使用的列（**联结键**）。也就是说，`ON` 是专门用来指定联结条件的，它能起到与 `WHERE` 相同的作用。需要指定多个键时，同样可以使用 `AND`、`OR`。在进行内联结时 `ON` 子句是必不可少的（如果没有 `ON` 会发生错误），并且 `ON` 必须书写在 `FROM` 和 `WHERE` 之间。

> 联结条件也可以使用“`=`”来记述。在语法上，还可以使用 `<=` 和 `BETWEEN` 等谓词。

3. **`SELECT` 子句**

```sql
SELECT
  SP.shop_id,
  SP.shop_name,
  P.product_id,
  P.product_name,
  P.sale_price
```

使用联结时 `SELECT` 子句中的列需要按照“`<表的别名>.<列名>`”的格式进行书写。从语法上来说，只有那些同时存在于两张表中的列必须使用这样的书写方式，其他的列这样直接书写列名也不会发生错误。

```sql
SELECT
  SP.shop_id,
  SP.shop_name,
  P.product_id,
  P.product_name,
  P.sale_price
FROM
  ShopProduct AS SP
  INNER JOIN Product AS P ON SP.product_id = P.product_id
WHERE
  SP.shop_id = '000A';
/*
+---------+-----------+------------+--------------+------------+
| shop_id | shop_name | product_id | product_name | sale_price |
+---------+-----------+------------+--------------+------------+
| 000A    | 东京      | 0001       | T恤衫        |       1000 |
| 000A    | 东京      | 0002       | 打孔器       |        500 |
| 000A    | 东京      | 0003       | 运动T恤      |       4000 |
+---------+-----------+------------+--------------+------------+
*/
```

像这样使用联结运算将满足相同规则的表联结起来时，`WHERE`、`GROUP BY`、`HAVING`、`ORDER BY` 等工具都可以正常使用。

### 2.4.外联结 —— `OUTER JOIN`

内联结之外比较重要的就是 **外联结**（OUTER JOIN）了。

外联结也是通过 `ON` 子句的联结键将两张表进行联结，并从两张表中同时选取相应的列的。基本的使用方法并没有什么不同，只是结果却有所不同。

```sql
SELECT
  SP.shop_id,
  SP.shop_name,
  P.product_id,
  P.product_name,
  P.sale_price
FROM
  ShopProduct AS SP
  RIGHT OUTER JOIN Product AS P ON SP.product_id = P.product_id;
/*
+---------+-----------+------------+--------------+------------+
| 000D    | 福冈      | 0001       | T恤衫        |       1000 |
| 000A    | 东京      | 0001       | T恤衫        |       1000 |
| 000B    | 名古屋    | 0002       | 打孔器       |        500 |
| 000A    | 东京      | 0002       | 打孔器       |        500 |
| 000C    | 大阪      | 0003       | 运动T恤      |       4000 |
| 000B    | 名古屋    | 0003       | 运动T恤      |       4000 |
| 000A    | 东京      | 0003       | 运动T恤      |       4000 |
| 000C    | 大阪      | 0004       | 菜刀         |       3000 |
| 000B    | 名古屋    | 0004       | 菜刀         |       3000 |
| NULL    | NULL      | 0005       | 高压锅       |       6800 |
| 000C    | 大阪      | 0006       | 叉子         |        500 |
| 000B    | 名古屋    | 0006       | 叉子         |        500 |
| 000C    | 大阪      | 0007       | 擦菜板       |        880 |
| 000B    | 名古屋    | 0007       | 擦菜板       |        880 |
| NULL    | NULL      | 0008       | 圆珠笔       |        100 |
+---------+-----------+------------+--------------+------------+
*/
```

#### 2.4.1.外联结要点

1. **选取出单张表中全部的信息**

内联结只能选取出同时存在于两张表中的数据，对于外联结来说，只要数据存在于某一张表当中，就能够读取出来。在实际的业务中，例如想要生成固定行数的单据时，就需要使用外联结。如果使用内联结的话，根据 `SELECT` 语句执行时商店库存状况的不同，结果的行数也会发生改变，生成的单据的版式也会受到影响，而使用外联结能够得到固定行数的结果。

外联结名称的由来也跟 `NULL` 有关，即“结果中包含原表中不存在（在原表之外）的信息”。相反，只包含表内信息的联结也就被称为 **内联结** 了。

2. **每张表都是主表吗**

外联结还有一点非常重要，那就是要把哪张表作为主表。最终的结果中会包含主表内所有的数据。指定主表的关键字是 `LEFT` 和 `RIGHT`。顾名思义，使用 `LEFT` 时 `FROM` 子句中写在左侧的表是主表，使用 `RIGHT` 时右侧的表是主表。

```sql
SELECT
  SP.shop_id,
  SP.shop_name,
  P.product_id,
  P.product_name,
  P.sale_price
FROM
  Product AS P
  LEFT OUTER JOIN ShopProduct AS SP ON SP.product_id = P.product_id;
/*
+---------+-----------+------------+--------------+------------+
| shop_id | shop_name | product_id | product_name | sale_price |
+---------+-----------+------------+--------------+------------+
| 000D    | 福冈      | 0001       | T恤衫        |       1000 |
| 000A    | 东京      | 0001       | T恤衫        |       1000 |
| 000B    | 名古屋    | 0002       | 打孔器       |        500 |
| 000A    | 东京      | 0002       | 打孔器       |        500 |
| 000C    | 大阪      | 0003       | 运动T恤      |       4000 |
| 000B    | 名古屋    | 0003       | 运动T恤      |       4000 |
| 000A    | 东京      | 0003       | 运动T恤      |       4000 |
| 000C    | 大阪      | 0004       | 菜刀         |       3000 |
| 000B    | 名古屋    | 0004       | 菜刀         |       3000 |
| NULL    | NULL      | 0005       | 高压锅       |       6800 |
| 000C    | 大阪      | 0006       | 叉子         |        500 |
| 000B    | 名古屋    | 0006       | 叉子         |        500 |
| 000C    | 大阪      | 0007       | 擦菜板       |        880 |
| 000B    | 名古屋    | 0007       | 擦菜板       |        880 |
| NULL    | NULL      | 0008       | 圆珠笔       |        100 |
+---------+-----------+------------+--------------+------------+
*/
```

外联结中使用 `LEFT`、`RIGHT` 来指定主表。使用二者所得到的结果完全相同。

### 2.5.多张表的联结

原则上联结表的数量并没有限制。

```sql
SELECT
  SP.shop_id,
  SP.shop_name,
  P.product_id,
  P.product_name,
  P.sale_price,
  IP.inventory_quantity
FROM
  ShopProduct AS SP
  INNER JOIN Product AS P ON SP.product_id = P.product_id
  INNER JOIN InventoryProduct AS IP ON SP.product_id = IP.product_id
WHERE
  IP.inventory_id = 'P001';
/*
+---------+-----------+------------+--------------+------------+--------------------+
| shop_id | shop_name | product_id | product_name | sale_price | inventory_quantity |
+---------+-----------+------------+--------------+------------+--------------------+
| 000A    | 东京      | 0001       | T恤衫        |       1000 |                  0 |
| 000A    | 东京      | 0002       | 打孔器       |        500 |                120 |
| 000A    | 东京      | 0003       | 运动T恤      |       4000 |                200 |
| 000B    | 名古屋    | 0002       | 打孔器       |        500 |                120 |
| 000B    | 名古屋    | 0003       | 运动T恤      |       4000 |                200 |
| 000B    | 名古屋    | 0004       | 菜刀         |       3000 |                  3 |
| 000B    | 名古屋    | 0006       | 叉子         |        500 |                 99 |
| 000B    | 名古屋    | 0007       | 擦菜板       |        880 |                999 |
| 000C    | 大阪      | 0003       | 运动T恤      |       4000 |                200 |
| 000C    | 大阪      | 0004       | 菜刀         |       3000 |                  3 |
| 000C    | 大阪      | 0006       | 叉子         |        500 |                 99 |
| 000C    | 大阪      | 0007       | 擦菜板       |        880 |                999 |
| 000D    | 福冈      | 0001       | T恤衫        |       1000 |                  0 |
+---------+-----------+------------+--------------+------------+--------------------+
*/
```

### 2.6.交叉联结 —— `CROSS JOIN`（笛卡儿积）

**交叉联结**（CROSS JOIN），是所有联结运算的基础，但其实这种联结在实际业务中并不会使用。交叉联结本身非常简单，但是其结果有点麻烦。

```sql
SELECT
  SP.shop_id,
  SP.shop_name,
  P.product_id,
  P.product_name
FROM
  ShopProduct AS SP
  CROSS JOIN Product AS P;
/*
+---------+-----------+------------+--------------+
| shop_id | shop_name | product_id | product_name |
+---------+-----------+------------+--------------+
| 000A    | 东京      | 0008       | 圆珠笔       |
| 000A    | 东京      | 0007       | 擦菜板       |
| 000A    | 东京      | 0006       | 叉子         |
| 000A    | 东京      | 0005       | 高压锅       |
| 000A    | 东京      | 0004       | 菜刀         |
| 000A    | 东京      | 0003       | 运动T恤      |
| 000A    | 东京      | 0002       | 打孔器       |
| 000A    | 东京      | 0001       | T恤衫        |
| 000A    | 东京      | 0008       | 圆珠笔       |
| 000A    | 东京      | 0007       | 擦菜板       |
| 000A    | 东京      | 0006       | 叉子         |
| 000A    | 东京      | 0005       | 高压锅       |
| 000A    | 东京      | 0004       | 菜刀         |
| 000A    | 东京      | 0003       | 运动T恤      |
| 000A    | 东京      | 0002       | 打孔器       |
| 000A    | 东京      | 0001       | T恤衫        |
| 000A    | 东京      | 0008       | 圆珠笔       |
| 000A    | 东京      | 0007       | 擦菜板       |
| 000A    | 东京      | 0006       | 叉子         |
| 000A    | 东京      | 0005       | 高压锅       |
| 000A    | 东京      | 0004       | 菜刀         |
| 000A    | 东京      | 0003       | 运动T恤      |
| 000A    | 东京      | 0002       | 打孔器       |
| 000A    | 东京      | 0001       | T恤衫        |
| 000B    | 名古屋    | 0008       | 圆珠笔       |
| 000B    | 名古屋    | 0007       | 擦菜板       |
| 000B    | 名古屋    | 0006       | 叉子         |
| 000B    | 名古屋    | 0005       | 高压锅       |
| 000B    | 名古屋    | 0004       | 菜刀         |
| 000B    | 名古屋    | 0003       | 运动T恤      |
| 000B    | 名古屋    | 0002       | 打孔器       |
| 000B    | 名古屋    | 0001       | T恤衫        |
| 000B    | 名古屋    | 0008       | 圆珠笔       |
| 000B    | 名古屋    | 0007       | 擦菜板       |
| 000B    | 名古屋    | 0006       | 叉子         |
| 000B    | 名古屋    | 0005       | 高压锅       |
| 000B    | 名古屋    | 0004       | 菜刀         |
| 000B    | 名古屋    | 0003       | 运动T恤      |
| 000B    | 名古屋    | 0002       | 打孔器       |
| 000B    | 名古屋    | 0001       | T恤衫        |
| 000B    | 名古屋    | 0008       | 圆珠笔       |
| 000B    | 名古屋    | 0007       | 擦菜板       |
| 000B    | 名古屋    | 0006       | 叉子         |
| 000B    | 名古屋    | 0005       | 高压锅       |
| 000B    | 名古屋    | 0004       | 菜刀         |
| 000B    | 名古屋    | 0003       | 运动T恤      |
| 000B    | 名古屋    | 0002       | 打孔器       |
| 000B    | 名古屋    | 0001       | T恤衫        |
| 000B    | 名古屋    | 0008       | 圆珠笔       |
| 000B    | 名古屋    | 0007       | 擦菜板       |
| 000B    | 名古屋    | 0006       | 叉子         |
| 000B    | 名古屋    | 0005       | 高压锅       |
| 000B    | 名古屋    | 0004       | 菜刀         |
| 000B    | 名古屋    | 0003       | 运动T恤      |
| 000B    | 名古屋    | 0002       | 打孔器       |
| 000B    | 名古屋    | 0001       | T恤衫        |
| 000B    | 名古屋    | 0008       | 圆珠笔       |
| 000B    | 名古屋    | 0007       | 擦菜板       |
| 000B    | 名古屋    | 0006       | 叉子         |
| 000B    | 名古屋    | 0005       | 高压锅       |
| 000B    | 名古屋    | 0004       | 菜刀         |
| 000B    | 名古屋    | 0003       | 运动T恤      |
| 000B    | 名古屋    | 0002       | 打孔器       |
| 000B    | 名古屋    | 0001       | T恤衫        |
| 000C    | 大阪      | 0008       | 圆珠笔       |
| 000C    | 大阪      | 0007       | 擦菜板       |
| 000C    | 大阪      | 0006       | 叉子         |
| 000C    | 大阪      | 0005       | 高压锅       |
| 000C    | 大阪      | 0004       | 菜刀         |
| 000C    | 大阪      | 0003       | 运动T恤      |
| 000C    | 大阪      | 0002       | 打孔器       |
| 000C    | 大阪      | 0001       | T恤衫        |
| 000C    | 大阪      | 0008       | 圆珠笔       |
| 000C    | 大阪      | 0007       | 擦菜板       |
| 000C    | 大阪      | 0006       | 叉子         |
| 000C    | 大阪      | 0005       | 高压锅       |
| 000C    | 大阪      | 0004       | 菜刀         |
| 000C    | 大阪      | 0003       | 运动T恤      |
| 000C    | 大阪      | 0002       | 打孔器       |
| 000C    | 大阪      | 0001       | T恤衫        |
| 000C    | 大阪      | 0008       | 圆珠笔       |
| 000C    | 大阪      | 0007       | 擦菜板       |
| 000C    | 大阪      | 0006       | 叉子         |
| 000C    | 大阪      | 0005       | 高压锅       |
| 000C    | 大阪      | 0004       | 菜刀         |
| 000C    | 大阪      | 0003       | 运动T恤      |
| 000C    | 大阪      | 0002       | 打孔器       |
| 000C    | 大阪      | 0001       | T恤衫        |
| 000C    | 大阪      | 0008       | 圆珠笔       |
| 000C    | 大阪      | 0007       | 擦菜板       |
| 000C    | 大阪      | 0006       | 叉子         |
| 000C    | 大阪      | 0005       | 高压锅       |
| 000C    | 大阪      | 0004       | 菜刀         |
| 000C    | 大阪      | 0003       | 运动T恤      |
| 000C    | 大阪      | 0002       | 打孔器       |
| 000C    | 大阪      | 0001       | T恤衫        |
| 000D    | 福冈      | 0008       | 圆珠笔       |
| 000D    | 福冈      | 0007       | 擦菜板       |
| 000D    | 福冈      | 0006       | 叉子         |
| 000D    | 福冈      | 0005       | 高压锅       |
| 000D    | 福冈      | 0004       | 菜刀         |
| 000D    | 福冈      | 0003       | 运动T恤      |
| 000D    | 福冈      | 0002       | 打孔器       |
| 000D    | 福冈      | 0001       | T恤衫        |
+---------+-----------+------------+--------------+
*/
```

对满足相同规则的表进行交叉联结的集合运算符是 `CROSS JOIN`（**笛卡儿积**）。进行交叉联结时无法使用内联结和外联结中所使用的 `ON` 子句，这是因为交叉联结是对两张表中的全部记录进行交叉组合，因此结果中的记录数通常是两张表中行数的乘积。

内联结是交叉联结的一部分，“内”也可以理解为“包含在交叉联结结果中的部分”。相反，外联结的“外”可以理解为“交叉联结结果之外的部分”。交叉联结没有应用到实际业务之中的原因有两个。一是其结果没有实用价值，二是由于其结果行数太多，需要花费大量的运算时间和高性能设备的支持。

### 2.7.联结的特定语法和过时语法

```sql
-- 使用过时语法的内联结
SELECT
  SP.shop_id,
  SP.shop_name,
  SP.product_id,
  P.product_name,
  P.sale_price
FROM
  ShopProduct SP,
  Product P
WHERE
  SP.product_id = P.product_id
  AND SP.shop_id = '000A';
/*
+---------+-----------+------------+--------------+------------+
| shop_id | shop_name | product_id | product_name | sale_price |
+---------+-----------+------------+--------------+------------+
| 000A    | 东京      | 0001       | T恤衫        |       1000 |
| 000A    | 东京      | 0002       | 打孔器       |        500 |
| 000A    | 东京      | 0003       | 运动T恤      |       4000 |
+---------+-----------+------------+--------------+------------+
*/
```

这样的书写方式所得到的结果与标准语法完全相同，并且这样的语法可以在所有的 DBMS 中执行，并不能算是特定的语法，只是过时了而已。但是，由于这样的语法不仅过时，而且还存在很多其他的问题，因此不推荐大家使用，理由主要有以下三点：

1. 使用这样的语法无法马上判断出到底是内联结还是外联结（又或者是其他种类的联结）

2. 由于联结条件都写在 `WHERE` 子句之中，因此无法在短时间内分辨出哪部分是联结条件，哪部分是用来选取记录的限制条件。

3. 不知道这样的语法到底还能使用多久。

### 2.8.关系除法

集合运算中的除法通常称为关系除法。关系是数学领域中对表或者视图的称谓，但是并没有定义像 `UNION` 或者 `EXCEPT` 这样专用的运算符。

```sql
-- pg
SELECT
  DISTINCT emp
FROM
  EmpSkills AS ES1
WHERE
  NOT EXISTS (
    SELECT
      skill
    FROM
      Skills
    EXCEPT
    SELECT
      skill
    FROM
      EmpSkills AS ES2
    WHERE
      ES1.emp = ES2.emp
  );
/*
 emp
------
 神崎
 相田
*/

-- mysql
SELECT
  DISTINCT emp
FROM
  EmpSkills AS ES1
WHERE
  NOT EXISTS (
    SELECT
      skill
    FROM
      Skills
    WHERE
      skill NOT IN (
        SELECT
          skill
        FROM
          EmpSkills AS ES2
        WHERE
          ES1.emp = ES2.emp
      )
  );
```

这样的结果满足了除法运算的基本规则。肯定有读者会产生这样的疑问：“到底上述运算中什么地方是除法运算呢？”实际上这和数值的除法既相似又有所不同，大家从与除法相对的乘法运算的角度去思考就能得到答案了。

除法和乘法是相辅相成的关系，除法运算的结果（商）乘以除数就能得到除法运算前的被除数了。例如对于 20÷4 = 5 来说，就是 5(商)×4(除数) = 20( 被除数)。关系除法中这样的规则也是成立的。通过商和除数相乘，也就是交叉联结，就能够得到作为被除数的集合了。如上所述，除法运算是集合运算中最复杂的运算，但是其在实际业务中的应用十分广泛。

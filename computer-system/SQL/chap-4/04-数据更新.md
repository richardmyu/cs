# 数据更新

[TOC]

## 1.数据的插入

### 1.1.什么是 `INSERT`

通过 `CREATE TABLE` 语句创建出来的表，可以被认为是一个空空如也的箱子。只有把数据装入到这个箱子后，它才能称为数据库。用来装入数据的 SQL 就是 `INSERT`（插入）。

### 1.2.`INSERT` 语句的基本语法

```sql
INSERT INTO <表名> (列 1, 列 2, 列 3, ……) VALUES (值 1, 值 2, 值 3, ……);

-- example
INSERT INTO
  ProductIns (
    product_id,
    product_name,
    product_type,
    sale_price,
    purchase_price,
    regist_date
  )
VALUES
  (
    '0001',
    'T 恤衫',
    '衣服',
    1000,
    500,
    '2009-09-20'
  );
```

将列名和值用逗号隔开，分别括在 `()`内，这种形式称为 **清单**。

```sql
-- 列清单
(product_id, product_name, product_type, sale_price, purchase_price, regist_date)

-- 值清单
('0001', 'T 恤衫', '衣服', 1000, 500,'2009-09-20')
```

> 当然，表名后面的列清单和 `VALUES` 子句中的值清单的列数必须保持一致。

- **多行 INSERT**

原则上，执行一次 `INSERT` 语句会插入一行数据。因此，插入多行时，通常需要循环执行相应次数的 `INSERT` 语句。虽然在大多数情况下该原则都是正确的，但它也仅仅是原则而已，其实很多 RDBMS 都支持一次插入多行数据，这样的功能称为 **多行 INSERT**（multi row INSERT）。

```sql
-- 多行 INSERT （Oracle 以外）
INSERT INTO
  ProductIns
VALUES
  ('0002', '打孔器', '办公用品', 500, 320, '2009-09-11'),
  ('0003', '运动 T 恤', '衣服', 4000, 2800, NULL),
  ('0004', '菜刀', '厨房用具', 3000, 2800, '2009-09-20');

-- Oracle 中的多行 INSERT
INSERT
  ALL INTO ProductIns
VALUES
  ('0002', '打孔器', '办公用品', 500, 320, '2009-09-11') INTO ProductIns
VALUES
  ('0003', '运动 T 恤', '衣服', 4000, 2800, NULL) INTO ProductIns
VALUES
  ('0004', '菜刀', '厨房用具', 3000, 2800, '2009-09-20')
SELECT
  *
FROM
  DUAL;
```

使用该语法时请注意以下几点：

1. `INSERT` 语句的书写内容及插入的数据是否正确。若不正确会发生 `INSERT` 错误，但是由于是多行插入，和特定的单一行插入相比，想要找出到底是哪行哪个地方出错了，就变得十分困难。
>
2. 多行 `INSERT` 的语法并不适用于所有的 RDBMS。该语法适用于 DB2、SQL、SQL Server、PostgreSQL 和 MySQL，但不适用于 Oracle。

### 1.3.列清单的省略

对表进行全列 `INSERT` 时，可以省略表名后的列清单。这时 `VALUES` 子句的值会默认按照从左到右的顺序赋给每一列。

```sql
-- 包含列清单
INSERT INTO
  ProductIns (
    product_id,
    product_name,
    product_type,
    sale_price,
    purchase_price,
    regist_date
  )
VALUES
  (
    '0005',
    '高压锅',
    '厨房用具',
    6800,
    5000,
    '2009-01-15'
  );

-- 省略列清单
INSERT INTO
  ProductIns
VALUES
  ('0005', '高压锅', '厨房用具', 6800, 5000, '2009-01-15');
```

### 1.4.插入 `NULL`

`INSERT` 语句中想给某一列赋予 `NULL` 值时，可以直接在 `VALUES` 子句的值清单中写入 `NULL`。

```sql
INSERT INTO
  ProductIns
VALUES
  ('0005', '高压锅', '厨房用具', 6800, NULL, '2009-01-15');
```

但是，想要插入 `NULL` 的列一定不能设置 `NOT NULL` 约束。向设置了 `NOT NULL` 约束的列中插入 `NULL` 时，`INSERT` 语句会出错，导致数据插入失败（通过 `INSERT` 语句插入的数据无法正常插入到表中，但之前已经插入的数据并不会被破坏）。

```sql
INSERT INTO
  ProductIns
VALUES
  (NULL, '高压锅', '厨房用具', 6800, NULL, '2009-01-15');
-- ERROR 1048 (23000): Column 'product_id' cannot be null
```

> 不仅是 `INSERT`，`DELETE` 和 `UPDATE` 等更新语句也一样，SQL 语句执行失败时都不会对表中数据造成影响。

### 1.5.插入默认值

我们还可以向表中插入 **默认值**（初始值）。可以通过在创建表的 `CREATE TABLE` 语句中设置 **`DEFAULT`** 约束来设定默认值。

```sql
CREATE TABLE ProductIns (
  product_id CHAR(4) NOT NULL,
  -- （ 略 ）
  sale_price INTEGER DEFAULT 0,
  -- 销售单价的默认值设定为0;
  -- （ 略 ）
  PRIMARY KEY (product_id)
);
```

如果在创建表的同时设定了默认值，就可以在 `INSERT` 语句中自动为列赋值了。默认值的使用方法通常有显式和隐式两种。

- **通过显式方法插入默认值**

在 `VALUES` 子句中指定 `DEFAULT` 关键字。

```sql
INSERT INTO
  ProductIns
VALUES
  (
    '0007',
    '擦菜板',
    '厨房用具',
    DEFAULT,
    790,
    '2009-04-28'
  );
/*
+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0007       | 擦菜板       | 厨房用具     |          0 |            790 | 2009-04-28  |
+------------+--------------+--------------+------------+----------------+-------------+
*/
```

- **通过隐式方法插入默认值**

插入默认值时也可以不使用 `DEFAULT` 关键字，只要在列清单和 `VALUES` 中省略设定了默认值的列就可以了。

```sql
INSERT INTO
  ProductIns (
    product_id,
    product_name,
    product_type,
    purchase_price,
    regist_date
  )
VALUES
  (
    '0008',
    '擦菜板',
    '厨房用具',
    7910,
    '2009-04-28'
  );
/*
+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0008       | 擦菜板       | 厨房用具     |          0 |           7910 | 2009-04-28  |
+------------+--------------+--------------+------------+----------------+-------------+
*/
```

> **注意**：插入数据时，当值清单数据不全时，要指定列清单形式才能插入正确；除非使用 `DEFAULT` 关键字指定缺省值。

如果省略了没有设定默认值的列，该列的值就会被设定为 `NULL`。因此，如果省略的是设置了 `NOT NULL` 约束的列，`INSERT` 语句就会出错。

```sql
-- 省略 purchase_price 列（无约束）：会赋予“NULL”
INSERT INTO
  ProductIns (
    product_id,
    product_name,
    product_type,
    sale_price,
    regist_date
  )
VALUES
  (
    '0008',
    '圆珠笔',
    '办公用品',
    100,
    '2009-11-11'
  );

-- 省略 product_name 列（设置了 NOT NULL 约束）：错误！
INSERT INTO
  ProductIns (
    product_id,
    product_type,
    sale_price,
    purchase_price,
    regist_date
  )
VALUES
  (
    '0009',
    '办公用品',
    1000,
    500,
    '2009-12-12'
  );

/*
 错误：null value in column "product_name"
 of relation "productins" violates not-null constraint
 描述：失败，行包含 (0009, null, 办公用品，1000, 500, 2009-12-12).
 */
```

### 1.6.从其他表中复制数据

```sql
-- 用来插入数据的商品复制表
CREATE TABLE ProductCopy (
  product_id CHAR(4) NOT NULL,
  product_name VARCHAR(100) NOT NULL,
  product_type VARCHAR(32) NOT NULL,
  sale_price INTEGER,
  purchase_price INTEGER,
  regist_date DATE,
  PRIMARY KEY (product_id)
);

-- 将商品表中的数据复制到商品复制表中
INSERT INTO
  ProductCopy (
    product_id,
    product_name,
    product_type,
    sale_price,
    purchase_price,
    regist_date
  )
SELECT
  product_id,
  product_name,
  product_type,
  sale_price,
  purchase_price,
  regist_date
FROM
  Product;
```

执行该 `INSERT … SELECT` 语句时，如果原来 Product 表中有 8 行数据，那么 ProductCopy 表中也会插入完全相同的 8 行数据。当然，Product 表中的原有数据不会发生改变。因此，`INSERT … SELECT` 语句可以在需要进行数据备份时使用。

```sql
-- 根据商品种类进行汇总的表；
CREATE TABLE ProductType (
  product_type VARCHAR(32) NOT NULL,
  sum_sale_price INTEGER,
  sum_purchase_price INTEGER,
  PRIMARY KEY (product_type)
);

INSERT INTO
  ProductType (product_type, sum_sale_price, sum_purchase_price)
SELECT
  product_type,
  SUM(sale_price),
  SUM(purchase_price)
FROM
  Product
GROUP BY
  product_type;

-- 确认插入的数据行
SELECT
  *
FROM
  ProductType;
/*
+--------------+----------------+--------------------+
| product_type | sum_sale_price | sum_purchase_price |
+--------------+----------------+--------------------+
| 办公用品     |            600 |                320 |
| 厨房用具     |          11180 |               8590 |
| 衣服         |           5000 |               3300 |
+--------------+----------------+--------------------+
*/
```

`INSERT` 语句的 `SELECT` 语句中，可以使用 `WHERE` 子句等任何 SQL 语法（但使用 `ORDER BY` 子句并不会产生任何效果，因为无法保证表内部记录的排列顺序）。

## 2.数据的删除

### 2.1.`DROP TABLE` 语句和 `DELETE` 语句

删除数据的方法大体可以分为以下两种。

- `DROP TABLE` 语句可以将表完全删除
>
- `DELETE` 语句会留下表（容器），而删除表中的全部数据

### 2.2.`DELETE` 语句的基本语法

```sql
DELETE FROM <表名>;
```

如果语句中忘了写 `FROM`，而是写成了“`DELETE < 表名 >`”，或者写了多余的列名，都会出错，无法正常执行。

前者无法正常执行的原因是删除对象不是表，而是表中的数据行（记录）。

> 与 `INSERT` 语句相同，数据的更新也是以记录（行）为基本单位进行的。

后者错误的原因也是如此。因为 `DELETE` 语句的对象是行而不是列，所以 `DELETE` 语句无法只删除部分列的数据。因此，在 `DELETE` 语句中指定列名是错误的。当然，使用星号的写法（`DELETE * FROM Product;`）也是不对的，同样会出错。

### 2.3.指定删除对象的 `DELETE` 语句

想要删除部分数据行时，可以像 `SELECT` 语句那样使用 `WHERE` 子句指定删除条件。这种指定了删除对象的 `DELETE` 语句称为 **搜索型 `DELETE`**。

> 虽然“**搜索型 `DELETE`**”是正式用语，但实际上这种说法并不常用，而是简单地称为 `DELETE` 语句。

```sql
DELETE FROM
  Product
WHERE
  sale_price >= 4000;

/*
+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-09-20  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | NULL        |
| 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-09-20  |
| 0005       | 高压锅       | 厨房用具     |       6800 |           5000 | 2009-01-15  |
| 0006       | 叉子         | 厨房用具     |        500 |           NULL | 2009-09-20  |
| 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2008-04-28  |
| 0008       | 圆珠笔       | 办公用品     |        100 |           NULL | 2009-11-11  |
+------------+--------------+--------------+------------+----------------+-------------+

do something

+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-09-20  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |
| 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-09-20  |
| 0006       | 叉子         | 厨房用具     |        500 |           NULL | 2009-09-20  |
| 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2008-04-28  |
| 0008       | 圆珠笔       | 办公用品     |        100 |           NULL | 2009-11-11  |
+------------+--------------+--------------+------------+----------------+-------------+
*/
```

与 `SELECT` 语句不同的是，`DELETE` 语句中不能使用 `GROUP BY`、 `HAVING` 和 `ORDER BY` 三类子句，而只能使用 `WHERE` 子句。原因很简单，`GROUP BY` 和 `HAVING` 是从表中选取数据时用来改变抽取数据形式的，而 `ORDER BY` 是用来指定取得结果显示顺序的。因此，在删除表中数据时它们都起不到什么作用。

### 2.4.删除和舍弃

标准 SQL 中用来从表中删除数据的只有 `DELETE` 语句。但是，很多数据库产品中还存在另外一种被称为 `TRUNCATE` 的语句。这些产品主要包括 Oracle、SQL Server、PostgreSQL、MySQL 和 DB2。

`TRUNCATE` 是舍弃的意思，具体的使用方法如下所示。

```sql
TRUNCATE <表名>;
```

与 `DELETE` 不同的是，`TRUNCATE` 只能删除表中的全部数据，而不能通过 `WHERE` 子句指定条件来删除部分数据。也正是因为它不能具体地控制删除对象，所以其处理速度比 `DELETE` 要快得多。实际上，`DELETE` 语句在 `DML` 语句中也属于处理时间比较长的，因此需要删除全部数据行时，使用 `TRUNCATE` 可以缩短执行时间。

```sql
mysql> TRUNCATE Product;
Query OK, 0 rows affected (0.02 sec)

mysql> SELECT * FROM Product;
Empty set (0.00 sec)
```

> 但是，产品不同需要注意的地方也不尽相同。例如在 Oracle 中，把 `TRUNCATE` 定义为 DDL，而不是 DML。

## 3.数据的更新

### 3.1.`UPDATE` 语句的基本语法

使用 `UPDATE` 语句就可以改变表中的数据了。和 `INSERT` 语句、`DELETE` 语句一样，`UPDATE` 语句也属于 DML 语句。通过执行该语句，可以改变表中的数据。

```sql
UPDATE <表名>
   SET <列名> = <表达式>;

-- example
UPDATE
  Product
SET
  regist_date = '2009-10-10';

/*
+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-09-20  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | NULL        |
| 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-09-20  |
| 0005       | 高压锅       | 厨房用具     |       6800 |           5000 | 2009-01-15  |
| 0006       | 叉子         | 厨房用具     |        500 |           NULL | 2009-09-20  |
| 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2008-04-28  |
| 0008       | 圆珠笔       | 办公用品     |        100 |           NULL | 2009-11-11  |
+------------+--------------+--------------+------------+----------------+-------------+

do something

+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-10-10  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-10-10  |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | 2009-10-10  |
| 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-10-10  |
| 0005       | 高压锅       | 厨房用具     |       6800 |           5000 | 2009-10-10  |
| 0006       | 叉子         | 厨房用具     |        500 |           NULL | 2009-10-10  |
| 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2009-10-10  |
| 0008       | 圆珠笔       | 办公用品     |        100 |           NULL | 2009-10-10  |
+------------+--------------+--------------+------------+----------------+-------------+
*/
```

### 3.2.指定条件的 `UPDATE` 语句

更新数据时也可以像 `DELETE` 语句那样使用 `WHERE` 子句，这种指定更新对象的 `UPDATE` 语句称为 **搜索型 `UPDATE` 语句**。

```sql
UPDATE <表名>
   SET <列名> = <表达式>
 WHERE <条件>;

-- example
UPDATE
  Product
SET
  sale_price = sale_price * 10
WHERE
  product_type = '厨房用具';

/*
+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-09-20  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | NULL        |
| 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-09-20  |
| 0005       | 高压锅       | 厨房用具     |       6800 |           5000 | 2009-01-15  |
| 0006       | 叉子         | 厨房用具     |        500 |           NULL | 2009-09-20  |
| 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2008-04-28  |
| 0008       | 圆珠笔       | 办公用品     |        100 |           NULL | 2009-11-11  |
+------------+--------------+--------------+------------+----------------+-------------+

do something

+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-10-10  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-10-10  |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | 2009-10-10  |
| 0004       | 菜刀         | 厨房用具     |      30000 |           2800 | 2009-10-10  |
| 0005       | 高压锅       | 厨房用具     |      68000 |           5000 | 2009-10-10  |
| 0006       | 叉子         | 厨房用具     |       5000 |           NULL | 2009-10-10  |
| 0007       | 擦菜板       | 厨房用具     |       8800 |            790 | 2009-10-10  |
| 0008       | 圆珠笔       | 办公用品     |        100 |           NULL | 2009-10-10  |
+------------+--------------+--------------+------------+----------------+-------------+
*/
```

`SET` 子句中赋值表达式的右边不仅可以是单纯的值，还可以是包含列的表达式。

### 3.3.使用 `NULL` 进行更新

使用 `UPDATE` 也可以将列更新为 `NULL`（该更新俗称为 **NULL 清空**）。此时只需要将赋值表达式右边的值直接写为 `NULL` 即可。

```sql
UPDATE
  Product
SET
  regist_date = NULL
WHERE
  product_id = '0008';

/*
+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-09-20  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | NULL        |
| 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-09-20  |
| 0005       | 高压锅       | 厨房用具     |       6800 |           5000 | 2009-01-15  |
| 0006       | 叉子         | 厨房用具     |        500 |           NULL | 2009-09-20  |
| 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2008-04-28  |
| 0008       | 圆珠笔       | 办公用品     |        100 |           NULL | 2009-11-11  |
+------------+--------------+--------------+------------+----------------+-------------+

do something

+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-10-10  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-10-10  |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | 2009-10-10  |
| 0004       | 菜刀         | 厨房用具     |      30000 |           2800 | 2009-10-10  |
| 0005       | 高压锅       | 厨房用具     |      68000 |           5000 | 2009-10-10  |
| 0006       | 叉子         | 厨房用具     |       5000 |           NULL | 2009-10-10  |
| 0007       | 擦菜板       | 厨房用具     |       8800 |            790 | 2009-10-10  |
| 0008       | 圆珠笔       | 办公用品     |        100 |           NULL | NULL        |
+------------+--------------+--------------+------------+----------------+-------------+
*/
```

但是，只有未设置 `NOT NULL` 约束和主键约束的列才可以清空为 `NULL`。如果将设置了上述约束的列更新为 `NULL`，就会出错，这点与 `INSERT` 语句相同。

### 3.4.多列更新

`UPDATE` 语句的 `SET` 子句支持同时将多个列作为更新对象。

```sql
-- 使用逗号对列进行分隔排列
-- 在所有的 DBMS 中都可以使用
UPDATE
  Product
SET
  sale_price = sale_price * 10,
  purchase_price = purchase_price / 2
WHERE
  product_type = '厨房用具';

-- 将列用 () 括起来的清单形式
-- 在 PostgreSQL 和 DB2 中使用
UPDATE
  Product
SET
  (sale_price, purchase_price) = (sale_price * 10, purchase_price / 2)
WHERE
  product_type = '厨房用具';

/*
/*
+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-09-20  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | NULL        |
| 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-09-20  |
| 0005       | 高压锅       | 厨房用具     |       6800 |           5000 | 2009-01-15  |
| 0006       | 叉子         | 厨房用具     |        500 |           NULL | 2009-09-20  |
| 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2008-04-28  |
| 0008       | 圆珠笔       | 办公用品     |        100 |           NULL | 2009-11-11  |
+------------+--------------+--------------+------------+----------------+-------------+

do something

+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-09-20  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | NULL        |
| 0004       | 菜刀         | 厨房用具     |      30000 |           1400 | 2009-09-20  |
| 0005       | 高压锅       | 厨房用具     |      68000 |           2500 | 2009-01-15  |
| 0006       | 叉子         | 厨房用具     |       5000 |           NULL | 2009-09-20  |
| 0007       | 擦菜板       | 厨房用具     |       8800 |            395 | 2008-04-28  |
| 0008       | 圆珠笔       | 办公用品     |        100 |           NULL | 2009-11-11  |
+------------+--------------+--------------+------------+----------------+-------------+
*/
```

> **注意**：需要注意的是第一种方法——使用逗号将列进行分隔排列，这一方法在所有的 DBMS 中都可以使用。但是第二种方法——将列清单化，这一方法在某些 DBMS 中是无法使用的。因此，实际应用中通常都会使用第一种方法。

## 4.事务

### 4.1.什么是事务

在 RDBMS 中，**事务**（transaction）是对表中数据进行更新的单位。简单来讲，事务就是需要在 *同一个处理单元中执行的一系列更新处理的集合*。

对表进行更新需要使用 `INSERT`、`DELETE` 或者 `UPDATE` 三种语句。但通常情况下，更新处理并不是执行一次就结束了，而是需要执行一系列连续的操作。这时，事务就能体现出它的价值了。

### 4.2.创建事务

使用事务开始语句和事务结束语句，将一系列 DML 语句（`INSERT/UPDATE/DELETE` 语句）括起来，就实现了一个事务处理。

```sql
事务开始语句;

      DML语句①;
      DML语句②;
      DML语句③;
         .
         .
         .
事务结束语句（COMMIT 或者 ROLLBACK）;
```

这时需要特别注意的是事务的开始语句。实际上，在标准 SQL 中并没有定义事务的开始语句，而是由各个 DBMS 自己来定义的。比较有代表性的语法如下所示。

- SQL Server、PostgreSQL
  - `BEGIN TRANSACTION`
>
- MySQL
  - `START TRANSACTION`
>
- Oracle、DB2
  - 无

```sql
-- SQL Server PostgreSQL
BEGIN TRANSACTION;

-- 将运动T恤的销售单价降低1000日元
UPDATE
  Product
SET
  sale_price = sale_price - 1000
WHERE
  product_name = '运动T恤';

-- 将T恤衫的销售单价上浮1000日元
UPDATE
  Product
SET
  sale_price = sale_price + 1000
WHERE
  product_name = 'T恤衫';

COMMIT;

-- MySQL
START TRANSACTION;

-- 将运动T恤的销售单价降低1000日元
UPDATE
  Product
SET
  sale_price = sale_price - 1000
WHERE
  product_name = '运动T恤';

-- 将T恤衫的销售单价上浮1000日元
UPDATE
  Product
SET
  sale_price = sale_price + 1000
WHERE
  product_name = 'T恤衫';

COMMIT;

/*
+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-09-20  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | NULL        |
| 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-09-20  |
| 0005       | 高压锅       | 厨房用具     |       6800 |           5000 | 2009-01-15  |
| 0006       | 叉子         | 厨房用具     |        500 |           NULL | 2009-09-20  |
| 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2008-04-28  |
| 0008       | 圆珠笔       | 办公用品     |        100 |           NULL | 2009-11-11  |
+------------+--------------+--------------+------------+----------------+-------------+

do something

+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       2000 |            500 | 2009-09-20  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |
| 0003       | 运动T恤      | 衣服         |       3000 |           2800 | NULL        |
| 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-09-20  |
| 0005       | 高压锅       | 厨房用具     |       6800 |           5000 | 2009-01-15  |
| 0006       | 叉子         | 厨房用具     |        500 |           NULL | 2009-09-20  |
| 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2008-04-28  |
| 0008       | 圆珠笔       | 办公用品     |        100 |           NULL | 2009-11-11  |
+------------+--------------+--------------+------------+----------------+-------------+
*/
```

标准 SQL 中规定了一种悄悄开始事务处理的方法-- 没有“BEGIN TRANSACTION”这样明确的开始标志，希望大家注意事务默认开始的时间点。《标准 SQL 手册修订第 4 版》

事务的结束需要用户明确地给出指示。结束事务的指令有如下两种。

> 事务结束语句只有 `COMMIT` 和 `ROLLBACK` 两种，在所有的 RDBMS 中都是通用的。

1. **COMMIT——提交处理**

`COMMIT` 是提交事务包含的全部更新处理的结束指令，相当于文件处理中的覆盖保存。一旦提交，就无法恢复到事务开始前的状态了。

2. **ROLLBACK——取消处理**

`ROLLBACK` 是取消事务包含的全部更新处理的结束指令，相当于文件处理中的放弃保存。一旦回滚，数据库就会恢复到事务开始之前的状态。通常回滚并不会像提交那样造成大规模的数据损失。

### 4.3.事务处理何时开始

事务并没有标准的开始指令存在，而是根据 DBMS 的不同而不同。

实际上，几乎所有的数据库产品的事务都无需开始指令。这是因为大部分情况下，事务在数据库连接建立时就已经悄悄开始了，并不需要用户再明确发出开始指令。

像这样不使用指令而悄悄开始事务的情况下，应该如何区分各个事务呢？通常会有如下两种情况。

1. 每条 SQL 语句就是一个事务（**自动提交模式**）
>
2. 直到用户执行 `COMMIT` 或者 `ROLLBACK` 为止算作一个事务

通常的 DBMS 都可以选择其中任意一种模式。默认使用自动提交模式的 DBMS 有 SQL Server、PostgreSQL 和 MySQL 等。

自动提交的情况需要特别注意的是 `DELETE` 语句。如果不是自动提交，即使使用 `DELETE` 语句删除了数据表，也可以通过 `ROLLBACK` 命令取消该事务的处理，恢复表中的数据。但这仅限于明示开始事务，或者关闭自动提交的情况。如果不小心在自动提交模式下执行了 `DELETE` 操作，即使再回滚也无济于事了。

### 4.4.ACID 特性

DBMS 的事务都遵循四种特性，将这四种特性的首字母结合起来统称为 **ACID 特性**。这是所有 DBMS 都必须遵守的规则。

- **原子性**（Atomicity）
  - 原子性是指在事务结束时，其中所包含的更新处理要么全部执行，要么完全不执行。
  - 从事务中途停止的角度去考虑，就能比较容易理解原子性的重要性了。由于用户在一个事务中定义了两条 `UPDATE` 语句，DBMS 肯定不会只执行其中一条，否则就会对业务处理造成影响。
>
- **一致性**（Consistency）
  - 一致性（也称为完整性）指的是事务中包含的处理要满足数据库提前设置的约束，如主键约束或者 `NOT NULL` 约束等。对事务来说，不合法的 SQL 会被取消，不会执行。
  - 例如，设置了 `NOT NULL` 约束的列是不能更新为 `NULL` 的，试图插入违反主键约束的记录就会出错，无法执行。对事务来说，这些不合法的 SQL 会被回滚。也就是说，这些 SQL 处理会被取消，不会执行。
>
- **隔离性**（Isolation）
  - 隔离性指的是保证不同事务之间互不干扰的特性。该特性保证了事务之间不会互相嵌套。
  - 此外，在某个事务中进行的更改，在该事务结束之前，对其他事务而言是不可见的。因此，即使某个事务向表中添加了记录，在没有提交之前，其他事务也是看不到新添加的记录的。
>
- **持久性**（Durability）
  - 持久性也可以称为耐久性，指的是在事务（不论是提交还是回滚）结束后，DBMS 能够保证该时间点的数据状态会被保存的特性。即使由于系统故障导致数据丢失，数据库也一定能通过某种手段进行恢复。
  - 如果不能保证持久性，即使是正常提交结束的事务，一旦发生了系统故障，也会导致数据丢失，一切都需要从头再来。

# 面向对象进阶

## `@property` 装饰器

建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的 `getter`（访问器）和 `setter`（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用`@property` 包装器来包装 `getter` 和 `setter` 方法，使得对属性的访问既安全又方便，代码如下所示。

> [code](./property.py)

## `__slots__`

Python 是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。

但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义 `__slots__` 变量来进行限定。需要注意的是 `__slots__` 的限定只对当前类的对象生效，对子类并不起任何作用。

> [code](./slots.py)

## 静态方法

在类中定义的方法都是对象方法，有时有些方法并不需要属于类，或者在对象未创建之前就会调用，可以使用静态方法。

> [code](./static_method.py)

## 类方法

和静态方法比较类似，Python 还可以在类中定义类方法，类方法的第一个参数约定名为 `cls`，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象
。
> [code](./class_method.py)

## 类之间的关系

- `is-a`：也叫继承或泛化；
- `has-a`：通常称之为关联；
- `use-a`：通常称之为依赖；

> 关联关系如果是整体和部分的关联，那么我们称之为 **聚合关系**；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为 **合成关系**。

## 继承和多态

在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为 **父类**，也叫 超类 或 基类；得到继承信息的我们称之为 **子类**，也叫 派生类 或 衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为 **里氏替换原则**。

> [code](./inherit.py)

子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法 **重写**（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是 **多态**（poly-morphism）。

> [code](./poly_morphism.py)

所谓 **抽象类** 就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python 从语法层面并没有像 Java 或 C# 那样提供对抽象类的支持，但是我们可以通过 `abc` 模块的 `ABCMeta` 元类和 `abstractmethod` 包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。

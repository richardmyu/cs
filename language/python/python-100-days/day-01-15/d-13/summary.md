# 进程和线程

**进程** 就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据。操作系统管理所有进程的执行，为它们合理的分配资源。

进程有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。

一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得 CPU 调度的执行单元，这就是所谓的 **线程**。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。

## Python 中的多进程

[不使用进程](./order_exe.py)

[使用多进程](./concurrent_exe.py)

[错误的通信](./ping_pong.py)

## Python 中的多线程

[使用多线程](./test_threading.py)

[使用线程类创建](./test_threading_2.py)

因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为 “**临界资源**”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。

[临界混乱](./citical_shaos.py)

可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。

## 多进程还是多线程

无论是多进程还是多线程，只要数量一多，效率肯定上不去。

是否采用多任务的第二个考虑是任务的类型，可以把任务分为 **计算密集型** 和 **I/O 密集型**。

计算密集型任务的特点是要进行大量的计算，消耗 CPU 资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠 CPU 的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU 执行任务的效率就越低。计算密集型任务由于主要消耗 CPU 资源，这类任务用 Python 这样的脚本语言去执行效率通常很低，最能胜任这类任务的是 C 语言，我们之前提到过 Python 中有嵌入 C/C++代码的机制。

除了计算密集型任务，其他的涉及到网络、存储介质 I/O 的任务都可以视为 I/O 密集型任务，这类任务的特点是 CPU 消耗很少，任务的大部分时间都在等待 I/O 操作完成（因为 I/O 的速度远远低于 CPU 和内存的速度）。对于 I/O 密集型任务，如果启动多任务，就可以减少 I/O 等待时间从而让 CPU 高效率的运转。有一大类的任务都属于 I/O 密集型任务，这其中包括了我们很快会涉及到的网络应用和 Web 应用。

## 单线程 + 异步 I/O

现代操作系统对 I/O 操作的改进中最为重要的就是支持 **异步 I/O**。如果充分利用操作系统提供的异步 I/O 支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为 **事件驱动模型**。

Nginx 就是支持异步 I/O 的 Web 服务器，它在单核 CPU 上采用单进程模型就可以高效地支持多任务。在多核 CPU 上，可以运行多个进程（数量与 CPU 核心数相同），充分利用多核 CPU。用 Node.js 开发的服务器端程序也使用了这种工作模式，这也是当下并发编程的一种流行方案。

在 Python 语言中，单线程 + 异步 I/O 的编程模型称为 **协程**，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。

- 协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。
- 协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

如果想要充分利用 CPU 的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

<!-- TODO: NOT COMPLETED -->
